#include "System/ExtendedSystem.cuh"
#include "GlobalData/GlobalData.cuh"
#include "ParticleData/ExtendedParticleData.cuh"
#include "ParticleData/ParticleGroup.cuh"

#include "Integrator/IntegratorBase.cuh"
#include "Integrator/IntegratorFactory.cuh"
//#include <fstream>

namespace uammd{
namespace structured{
namespace Integrator{
namespace Special{
namespace Rerun{

	class  Rerun: public IntegratorBase{

		private:
			bool initialized     = false;
			std::string inputTrajectory;
			std::ifstream leggi;
		public:

      Rerun(std::shared_ptr<GlobalData>    gd,
           std::shared_ptr<ParticleGroup> pg,
           DataEntry& data,
           std::string name):IntegratorBase(gd,pg,data,name){
	      			inputTrajectory = data.getParameter<std::string>("inputTrajectory");
				leggi.open(inputTrajectory.c_str(), std::ifstream::in);
				if (!leggi.good())
				{
					System::log<System::CRITICAL>("[Rerun] (%s) Input trajectory file %s not found",name.c_str(), inputTrajectory.c_str());
				}
	      			System::log<System::MESSAGE>("[Rerun] Created Rerun integrator \"%s\"",name.c_str());
				System::log<System::MESSAGE>("[Rerun] (%s) Input trajectory : %s",name.c_str(),inputTrajectory.c_str());
			}

      			void init(){

				initialized = true;
			}

			real integrationStep(){
				int N              = this->pg->getNumberParticles();
				auto pos           = this->pd->getPos(access::location::gpu, access::mode::readwrite);
				auto groupIterator = this->pg->getIndexIterator(access::location::gpu);
				auto force         = this->pd->getForce(access::location::gpu, access::mode::readwrite);
				std::string lineaComodo;
				real passoTempo; 
				getline(leggi, lineaComodo); //skip first line
				leggi >> passoTempo;
				for (int i=2; i<=9; i++) // skip rest of the header
					getline(leggi, lineaComodo);
				int iLoc, tipo;

				std::vector <real3> posLoc;
				real3 real3Comodo;
				for (int i=0; i<N; i++)
				{
					//leggi >> iLoc >> tipo >> pos_ptr[i].x >> pos_ptr[i].y >> pos_ptr[i].z;
					leggi >> iLoc >> tipo >> real3Comodo.x >> real3Comodo.y >> real3Comodo.z;
					posLoc.push_back(real3Comodo);
				}
				
				if (leggi.eof())
				{
					System::log<System::CRITICAL>("[Rerun] (%s) Reached end of input trajectory file %s before scheduled time",name.c_str(), inputTrajectory.c_str());
				}

				thrust::for_each(thrust::cuda::par.on(stream),groupIterator,groupIterator + N,
                            [=] __host__ __device__ (int index){
			    		pos[index].x = posLoc[index].x;
			    		pos[index].y = posLoc[index].y;
			    		pos[index].z = posLoc[index].z;
					force[index] = make_real4(0);
					printf("IGNAZIO %f %d %f %f %f %f %f %f\n", passoTempo, index, pos[index].x, pos[index].y, pos[index].z, posLoc[index].x, posLoc[index].y, posLoc[index].z);
			    });

				fflush(stdout);
				CudaSafeCall(cudaStreamSynchronize(stream));
				CudaCheckError();
				return passoTempo;
			}

			void forwardTime() override {

				if(not initialized){
					this->init();
	    			}

				System::log<System::DEBUG1>("[Rerun] (%s) Performing rerun of step %llu",name.c_str(), this->gd->getFundamental()->getCurrentStep());

    				real passoTempo = this->integrationStep();				
				this->updateForce();

				this->gd->getFundamental()->setCurrentStep(this->gd->getFundamental()->getCurrentStep()+1);
				this->gd->getFundamental()->setSimulationTime(passoTempo);

				CudaSafeCall(cudaStreamSynchronize(stream));
				auto pos         = this->pd->getPos(access::location::cpu, access::mode::read);
				//printf("IGNAZIO %f %f %f %f %f %f %f\n", passoTempo, pos[0].x, pos[0].y, pos[0].z, pos[1].x, pos[1].y, pos[1].z);
			}

	};

}}}}}

REGISTER_INTEGRATOR(
    Rerun,Rerun,
    uammd::structured::Integrator::Special::Rerun::Rerun
)
