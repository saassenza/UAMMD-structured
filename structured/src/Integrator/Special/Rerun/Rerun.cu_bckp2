#include "System/ExtendedSystem.cuh"
#include "GlobalData/GlobalData.cuh"
#include "ParticleData/ExtendedParticleData.cuh"
#include "ParticleData/ParticleGroup.cuh"
#include "ParticleGroup/ParticleGroupUtils.cuh"

#include "Integrator/IntegratorBase.cuh"
#include "Integrator/IntegratorFactory.cuh"
#include "Integrator/IntegratorUtils.cuh"

#include <fstream>
#include <unistd.h>
#include "Utils/Measures/MeasuresBasic.cuh"

namespace uammd{
namespace structured{
namespace Integrator{
namespace Special{
namespace Rerun{

	class  Rerun: public IntegratorBase
	{
		private:
			std::string inputTrajectory;
			std::string outputTrajectory;
			std::string outputThermo;
			bool initialized = false;
			std::ifstream leggi;
			std::ofstream scrivi;
			struct readData {
				int id;
				real3 position;
			};
			thrust::host_vector<readData> coordsCPU; 
			thrust::device_vector<readData> coordsGPU; 
		public:
		  	Rerun(std::shared_ptr<GlobalData> gd, std::shared_ptr<ForceField> ff, std::shared_ptr<ParticleGroup> pg, DataEntry& data, std::string name):IntegratorBase(gd,pg,data,name)
			{
				inputTrajectory = data.getParameter<std::string>("inputTrajectory");
				outputTrajectory = data.getParameter<std::string>("outputTrajectory");
				outputThermo = data.getParameter<std::string>("outputThermo");
		  		System::log<System::MESSAGE>("[Rerun] Created Rerun integrator \"%s\"",name.c_str());
			}

			void init()
			{
	    			System::log<System::MESSAGE>("[Rerun] Performing initialization step");

				//Resize thrust vectors
				int N = this->pg->getNumberParticles();
				coordsCPU.resize(N);
				coordsGPU.resize(N);

                    		//Reset force to 0 and compute force
		                //this->resetForce();
	    			//this->updateForce();
	    			//CudaSafeCall(cudaStreamSynchronize(stream));
				//CudaCheckError();

				//Open stream 
				int flag;
				if (::access(inputTrajectory.c_str(), F_OK ) == -1 )
				{
					System::log<System::CRITICAL>("[Rerun] File %s not found", inputTrajectory.c_str());
				}
				leggi.open(inputTrajectory.c_str(), std::ifstream::in);
				scrivi.open(outputThermo.c_str(), std::ios::out);
				flag = ReadDump();

		                scrivi << "#Timestep ";

		                for(auto& interactor : this->topology->getInteractors())
				{
		    			scrivi << "Energy(" << interactor.first << ") ";
				}
		                scrivi << std::endl;

				{
					auto pos = this->pd->getPos(access::location::cpu, access::mode::read);
					auto id  = this->pd->getId(access::location::cpu, access::mode::read);
					auto groupIterator = this->pg->getIndexIterator(access::location::cpu);
					fori(0,N){
						int index = groupIterator[i];
						int id_ = id[index];
						real3 pos_ = make_real3(pos[index]);
					}
					real4* pos_ptr = pos.raw();
					printf("CHECK %f\n", pos_ptr[0].x);
				}

				leggi.close();
				scrivi.close();

				initialized = true;
			}

			int ReadDump()
			{
				std::string comstr;
				getline(leggi, comstr);
				real comodo;
				int indice, tipo, natoms;
				leggi >> comodo;
				printf("checkpoint 1\n");
				if (!leggi.eof())
				{
					this->gd->getFundamental()->setSimulationTime(comodo); // timestep
					getline(leggi, comstr);
					getline(leggi, comstr);
					leggi >> natoms; // # of atoms
					int N = this->pg->getNumberParticles();
					if (natoms != N)
					{
						System::log<System::CRITICAL>("[Rerun] # of atoms in file (%d) is distinct from # of atoms in simulation (%d)", natoms, N);
					}
					getline(leggi, comstr);
					getline(leggi, comstr);
					printf("checkpoint 2 %d\n", natoms);

					// box info
					Box box = this->gd->getEnsemble()->getBox();
					real box_left, box_right, box_size;
					leggi >> box_left >> box_right;
					box_size = box_right - box_left;
					box.boxSize.x = box_size/real(2.0);
					leggi >> box_left >> box_right;
					box_size = box_right - box_left;
					box.boxSize.y = box_size/real(2.0);
					leggi >> box_left >> box_right;
					box_size = box_right - box_left;
					box.boxSize.z = box_size/real(2.0);
					this->gd->getEnsemble()->setBox(box);
					getline(leggi, comstr);
					getline(leggi, comstr);
					printf("checkpoint 3\n");

					// coordinates
					int id;
					real3 pos;
					for (int i=0; i<natoms; i++)
					{
						leggi >> id >> comodo >> pos.x >> pos.y >> pos.z;
						readData idPos;
						idPos.id = id;
						idPos.position = pos;
						coordsCPU[i] = idPos;
					}
					coordsGPU = coordsCPU; // synchronization is implicit, no need to ask for it

					thrust::counting_iterator<int> start(0);
					auto pos           = this->pd->getPos(access::location::gpu, access::mode::readwrite);
					{
						const int* id2index      = pd->getIdOrderedIndices(access::location::gpu);
						real4* pos_ptr     = pos.raw();
						realData* coordsGPU_ptr = thrust::raw_pointer_cast(coordsGPU.data());
						thrust::for_each(thrust::cuda::par.on(stream), start, start + N, [=] __host__ __device__ (int index)
						{
							const readData idPosGPU = coordsGPU_ptr[index];
							const int indexParticleGPU = id2index[idPosGPU.id];
							const real3 posParticleGPU = idPosGPU.position;

							pos_ptr[indexParticleGPU] = posParticleGPU;
						});
					}
                        		CudaSafeCall(cudaDeviceSynchronize());
					CudaCheckError();
					//copyFromRef();
                        		//CudaSafeCall(cudaStreamSynchronize(stream));
					//CudaCheckError();
					//printf("CIAO2\n");
	    				//auto pos = this->pd->getPos(access::location::gpu, access::mode::readwrite);
					////for (int index=0; index<natoms; index++)
					////	//printf("CIAONE2 %d %f %f %f\n", index, posRef_ptr[index].x, posRef_ptr[index].y, posRef_ptr[index].z);
					////	printf("CIAONE2 %d %f %f %f\n", index, pos[index].x, pos[index].y, pos[index].z);
					
					getline(leggi, comstr);
					
					printf("checkpoint 4 %f %s\n", pos_loc_z[natoms-1], comstr.c_str());

					return 1;
				}
				else
				{
					return 0;
				}
			}

			void forwardTime() override 
			{
				if(not initialized)
				{
					this->init();
	    			}
	    			int is_finished = this->integrationStep();
				if (is_finished)
				{
					this->sys->setState(ExtendedSystem::SIMULATION_STATE::STOPPED);
				}
				this->gd->getFundamental()->setCurrentStep(this->gd->getFundamental()->getCurrentStep()+1);
				//this->gd->getFundamental()->setSimulationTime(this->gd->getFundamental()->getSimulationTime()+this->dt);
			}

			void integrationStep()
			{
				//this->updateForce();
				//int flag = ReadDump();
			}

	};

}}}}}

REGISTER_INTEGRATOR(
    Rerun,Rerun,
    uammd::structured::Integrator::Special::Rerun::Rerun
)
